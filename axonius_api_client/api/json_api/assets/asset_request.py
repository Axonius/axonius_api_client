# -*- coding: utf-8 -*-
"""Models for API requests & responses."""
import dataclasses
import datetime
import typing as t

import marshmallow
import marshmallow_jsonapi.fields as mm_fields

from ....constants.api import PAGE_SIZE
from ....tools import dt_now, dt_parse, get_query_id, listify
from ..base import BaseModel, BaseSchemaJson
from ..custom_fields import SchemaBool, SchemaDatetime, field_from_mm
from ..resources import PaginationRequest, PaginationSchema


class AssetRequestSchema(BaseSchemaJson):
    """Schema for getting asset data from Axonius."""

    page = mm_fields.Nested(
        PaginationSchema(),
        load_default=PaginationRequest,
        dump_default=PaginationRequest,
        description="Pagination settings for the request",
    )  # ResourceRequestSchema
    search = mm_fields.Str(
        load_default="",
        dump_default="",
        allow_none=True,
        # cortex does not allow_none, but we do to allow for empty searches
        description="search term for the request (unused?)",
    )  # FilterSchema
    filter = mm_fields.Str(
        load_default="",
        dump_default="",
        allow_none=True,
        description="AQL for the request",
    )  # FilterSchema
    history = SchemaDatetime(
        load_default=None,
        dump_default=None,
        allow_none=True,
        description="Get asset data for a specific point in time",
    )  # FilterSchema
    sort = mm_fields.Str(
        load_default=None,
        dump_default=None,
        allow_none=True,
    )  # ResourceRequestSchema
    get_metadata = SchemaBool(
        load_default=True,
        dump_default=True,
        description="Add pagination metadata to the response",
    )  # ResourceWithMetadataRequestSchema
    field_filters = mm_fields.List(
        mm_fields.Dict(),
        load_default=list,
        dump_default=list,
        allow_none=True,
        description="Field filters for the response",
    )  # EntityRequestSchema
    excluded_adapters = mm_fields.List(
        mm_fields.Dict(),
        load_default=list,
        dump_default=list,
        allow_none=True,
        description="Adapters to exclude from the response",
    )  # EntityRequestSchema
    asset_excluded_adapters = mm_fields.List(
        mm_fields.Dict(),
        load_default=list,
        dump_default=list,
        allow_none=True,
        description="Adapters to exclude from the response",
    )  # EntityRequestSchema
    asset_filters = mm_fields.List(
        mm_fields.Dict(),
        load_default=list,
        dump_default=list,
        allow_none=True,
        description="Asset filters for the request",
    )  # EntityRequestSchema
    expressions = mm_fields.List(
        mm_fields.Dict(),
        load_default=list,
        dump_default=list,
        allow_none=True,
        description="Expressions for the request, generated by a query wizard",
    )  # EntityRequestSchema
    fields = mm_fields.Dict(
        load_default=dict,
        dump_default=dict,
        allow_none=True,
        description="Fields to include in the response",
    )  # EntityRequestSchema
    include_details = SchemaBool(
        load_default=False,
        dump_default=False,
        description="Include aggregation details in the response",
    )  # EntityRequestSchema
    include_notes = SchemaBool(
        load_default=False,
        dump_default=False,
        description="Include notes objects for each asset in the response",
    )  # EntityRequestSchema
    use_cursor = SchemaBool(
        load_default=True,
        dump_default=True,
        description="Use a cursor based pagination",
    )  # EntityRequestSchema
    cursor_id = mm_fields.Str(
        load_default=None,
        dump_default=None,
        allow_none=True,
        description="Cursor to use for pagination from first response with use_cursor=True",
    )  # EntityRequestSchema
    saved_query_id = mm_fields.Str(
        load_default=None,
        dump_default=None,
        allow_none=True,
        description="ID of saved query that originated this request",
    )  # EntityRequestSchema
    query_id = mm_fields.Str(
        load_default=None,
        dump_default=None,
        allow_none=True,
        description="ID of query that originated this request, if not set will be generated",
    )  # EntityRequestSchema
    source_component = mm_fields.Str(
        load_default=None,
        dump_default=None,
        allow_none=True,
        description="Component that originated this request",
    )  # EntityRequestSchema
    frontend_sent_time = SchemaDatetime(
        load_default=None,
        dump_default=None,
        allow_none=True,
        description="Time that the request was sent from the frontend",
    )  # EntityRequestSchema
    filter_out_non_existing_fields = SchemaBool(
        load_default=True,
        dump_default=True,
        description="Filter out fields that don't exist in the request",
    )  # EntityRequestSchema
    is_refresh = SchemaBool(
        load_default=False,
        dump_default=False,
        description="If true, suppress logging, ignored when using cursor",
    )  # EntityRequestSchema
    null_for_non_exist = SchemaBool(
        load_default=False,
        dump_default=False,
        description="Return null for fields that don't exist in the request",
    )  # EntityRequestSchema
    max_field_items = mm_fields.Integer(
        load_default=None,
        dump_default=None,
        description="Maximum number of items to return for fields that are lists",
    )  # EntityRequestSchema
    complex_fields_preview_limit = mm_fields.Integer(
        load_default=None,
        dump_default=None,
        allow_none=True,
        description="Maximum number of items to return for complex fields",
    )  # EntityRequestSchema
    use_heavy_fields_collection = SchemaBool(
        load_default=None,
        dump_default=None,
        allow_none=True,
        description="Use the heavy fields collection for this request",
    )  # ForceHeavyFieldsSchema
    download_id = mm_fields.Str(
        load_default=None,
        dump_default=None,
        allow_none=True,
        description="ID of download that originated this request, ignored when using cursor",
    )  # ExportLargeCsvSchema
    use_cache_entry = SchemaBool(
        load_default=False,
        dump_default=False,
        description="Use a cache entry for this request, ignored when using cursor",
    )  # UseCacheEntrySchema
    always_cached_query = SchemaBool(
        load_default=False,
        dump_default=False,
        description="Always use a cache entry for this request, ignored when using cursor",
    )  # EntityRequestSchema
    wait_for_data = SchemaBool(
        load_default=False,
        dump_default=False,
        description="Wait for data to be available for this request, ignored when using cursor",
    )  # EntityRequestSchema
    should_exclude_complex_fields = SchemaBool(
        load_default=False,
        dump_default=False,
        description="Exclude complex fields from the request, ignored when using cursor",
    )  # EntityRequestSchema
    should_split_by_adapter = SchemaBool(
        load_default=False,
        dump_default=False,
        description="Split the response by adapter, ignored when using cursor",
    )  # EntityRequestSchema
    should_split_complex_objects = SchemaBool(
        load_default=True,
        dump_default=True,
        description="Split complex objects into multiple fields, ignored when using cursor",
    )  # EntityRequestSchema
    delimiter = mm_fields.Str(
        load_default=None,
        dump_default=None,
        allow_none=True,
        description="Delimiter to use for CSV export, ignored when using cursor",
    )  # EntityRequestSchema
    field_to_split_by = mm_fields.Str(
        load_default=None,
        dump_default=None,
        allow_none=True,
        description="Field to split the response by, ignored when using cursor",
    )  # EntityRequestSchema
    file_name = mm_fields.Str(
        load_default=None,
        dump_default=None,
        allow_none=True,
        description="File name to use for CSV export, ignored when using cursor",
    )  # EntityRequestSchema
    max_rows = mm_fields.Integer(
        load_default=None,
        dump_default=None,
        description="Maximum number of rows to return for CSV export, ignored when using cursor",
    )  # EntityRequestSchema

    class Meta:
        """Pass."""

        type_ = "entity_request_schema"

    @staticmethod
    def get_model_cls() -> t.Any:
        """Get the model for this schema."""
        return AssetRequest

    # noinspection PyUnusedLocal
    @marshmallow.post_dump
    def post_dump_process(self, data, **kwargs) -> dict:
        """Fix up request data for the REST API.

        Notes:
            PBUG: No assets come back if:
                - sort is an empty string
            PBUG: 400 Error "Type error: got an unexpected keyword argument" if:
                - sort is None
            PBUG: 422 Error "Field may not be null." if:
                - search is None
                - file_name is None
        """
        sort = data.get("sort")
        if not (isinstance(sort, str) and sort.strip()):
            data.pop("sort", None)

        search = data.get("search")
        if not isinstance(search, str):
            data["search"] = ""

        file_name = data.get("file_name")
        if not isinstance(file_name, str):
            data["file_name"] = ""

        # strip out any None values to reduce unknown behavior
        data = {k: v for k, v in data.items() if v is not None}
        return data


SCHEMA = AssetRequestSchema()


@dataclasses.dataclass
class AssetRequest(BaseModel):
    """Model for getting asset data from Axonius"""

    page: t.Optional[PaginationRequest] = field_from_mm(SCHEMA, "page")
    search: t.Optional[str] = field_from_mm(SCHEMA, "search")
    filter: t.Optional[str] = field_from_mm(SCHEMA, "filter")
    history: t.Optional[datetime.datetime] = field_from_mm(SCHEMA, "history")
    sort: t.Optional[str] = field_from_mm(SCHEMA, "sort")
    get_metadata: bool = field_from_mm(SCHEMA, "get_metadata")
    field_filters: t.Optional[t.List[dict]] = field_from_mm(SCHEMA, "field_filters")
    excluded_adapters: t.Optional[t.List[dict]] = field_from_mm(SCHEMA, "excluded_adapters")
    asset_excluded_adapters: t.Optional[t.List[dict]] = field_from_mm(
        SCHEMA, "asset_excluded_adapters"
    )
    asset_filters: t.Optional[t.List[dict]] = field_from_mm(SCHEMA, "asset_filters")
    expressions: t.Optional[t.List[dict]] = field_from_mm(SCHEMA, "expressions")
    fields: t.Optional[dict] = field_from_mm(SCHEMA, "fields")
    include_details: bool = field_from_mm(SCHEMA, "include_details")
    include_notes: bool = field_from_mm(SCHEMA, "include_notes")
    use_cursor: bool = field_from_mm(SCHEMA, "use_cursor")
    cursor_id: t.Optional[str] = field_from_mm(SCHEMA, "cursor_id")
    saved_query_id: t.Optional[str] = field_from_mm(SCHEMA, "saved_query_id")
    query_id: t.Optional[str] = field_from_mm(SCHEMA, "query_id")
    source_component: t.Optional[str] = field_from_mm(SCHEMA, "source_component")
    frontend_sent_time: t.Optional[datetime.datetime] = field_from_mm(SCHEMA, "frontend_sent_time")
    filter_out_non_existing_fields: bool = field_from_mm(SCHEMA, "filter_out_non_existing_fields")
    is_refresh: bool = field_from_mm(SCHEMA, "is_refresh")
    null_for_non_exist: bool = field_from_mm(SCHEMA, "null_for_non_exist")
    max_field_items: t.Optional[int] = field_from_mm(SCHEMA, "max_field_items")
    complex_fields_preview_limit: t.Optional[int] = field_from_mm(
        SCHEMA, "complex_fields_preview_limit"
    )

    download_id: t.Optional[str] = field_from_mm(SCHEMA, "download_id")
    use_heavy_fields_collection: t.Optional[bool] = field_from_mm(
        SCHEMA, "use_heavy_fields_collection"
    )
    use_cache_entry: bool = field_from_mm(SCHEMA, "use_cache_entry")
    always_cached_query: bool = field_from_mm(SCHEMA, "always_cached_query")
    wait_for_data: bool = field_from_mm(SCHEMA, "wait_for_data")
    should_exclude_complex_fields: bool = field_from_mm(SCHEMA, "should_exclude_complex_fields")
    should_split_by_adapter: bool = field_from_mm(SCHEMA, "should_split_by_adapter")
    should_split_complex_objects: bool = field_from_mm(SCHEMA, "should_split_complex_objects")
    delimiter: t.Optional[str] = field_from_mm(SCHEMA, "delimiter")
    field_to_split_by: t.Optional[str] = field_from_mm(SCHEMA, "field_to_split_by")
    file_name: t.Optional[str] = field_from_mm(SCHEMA, "file_name")
    max_rows: t.Optional[int] = field_from_mm(SCHEMA, "max_rows")

    SCHEMA: t.ClassVar[marshmallow.Schema] = SCHEMA

    def __post_init__(self):
        """Dataclasses post init."""
        if not isinstance(self.page, PaginationRequest):
            self.page = PaginationRequest()
        if not isinstance(self.search, str):
            self.search = ""
        if not isinstance(self.file_name, str):
            self.file_name = ""
        self.field_filters: t.List[dict] = listify(self.field_filters)
        self.excluded_adapters: t.List[dict] = listify(self.excluded_adapters)
        self.asset_excluded_adapters: t.List[dict] = listify(self.asset_excluded_adapters)
        self.asset_filters: t.List[dict] = listify(self.asset_filters)
        self.expressions: t.List[dict] = listify(self.expressions)
        self.query_id: str = get_query_id(self.query_id)
        self.frontend_sent_time: t.Optional[datetime.datetime] = dt_parse(
            obj=self.frontend_sent_time,
            allow_none=True,
            as_none=dt_now(),
        )
        if not isinstance(self.fields, dict):
            if isinstance(self.fields, (str, bytes, list)):
                self.fields = {"fields": listify(self.fields)}
            elif not isinstance(self.fields, dict):
                self.fields = {}

    @staticmethod
    def get_schema_cls() -> t.Any:
        """Get the schema for this model."""
        return AssetRequestSchema

    def set_limit(self, value: t.Optional[int]) -> int:
        """Set the page size for the request."""
        return self.page.set_limit(value)

    def set_offset(self, value: t.Optional[int]) -> int:
        """Set the row start for the request."""
        return self.page.set_offset(value)

    def set_page(self, limit: t.Optional[int] = 0, offset: t.Optional[int] = PAGE_SIZE):
        """Set the page size (limit) and row start (offset) for the request."""
        self.set_limit(limit)
        self.set_offset(offset)
